Error with sort: must be related somehow to memory problem. 
Do not know where though? Perhaps premature deallocation of memory?
----------------------------------------------------------------------
Oct. 10, 2010
ts_cl[TI_SYSTEM_UPDATE] = new Timer("(rtps) system update", time_offset, print_freq);
----------------------------------------------------------------------
Oct. Got it. Number of particles must be a power of two. So MUST IMPlement early 
termination. However, that is true for bitonic (and perhaps) radix sort. 
It should not affect hashing in any way!

In GridParam: store actual number of particles.
In Settings: store max number of particles (power of two). 
----------------------------------------------------------------------
Nov. 11, 2010
----------------------------------------------------------------------
Can I perhaps get grid resolution = power of 2?  This will accelerate
some operations
----------------------------------------------------------------------
immediate return
queued to end: 0.486752 (ms)
queued to submit: 0.011904 (ms)
submit to start: 0.230176 (ms)
start to end: 0.244672 (ms)
----------------------------------------------------------------------
Nov. 23, 2010
Given list of indices and hashes (of all the particles), sort the hashes.
The list of indices refer to the particles in order, with the cells ordered
according to its hash. 

In buildDatastructures, I create the arrays cl_cell_indices_start, 
cl_cell_indices_end, and cl_cell_indices_nb. 

Next, I must compactify the indices and hash array. Remove all indices
where cl_cell_indices_nb are zero. Create an array of int4 where each 
quadruple is really: (hash, nb, start), which refer to the particle at
that index. 

What we want is that the order of the hashes be in z_curve order, and NOT in 
grid order. But the hash in the int4 array is the grid hash. INTERESTING, NO? 
I also need an array (including the zeros), which contain the (nb,start)
of a grid cell, so the grid hash is the index (not necessarily the z_curve hash), 
so I can deduce the (i,j,k) efficiently, via shift operators (if the grid size
is a power of two. 
----------------------------------------------------------------------
Does not work yet (version of compactification with int4)
----------------------------------------------------------------------
Nov. 25, 2010
- new branch rtps_compact, for the development of density calculation based on compact array
----------------------------------------------------------------------
Nov 26, 2010
- in gridParam structure, be careful when adding int4 to the structure since
they should be aligned. So having int4, int4, int, int4 will ikely to lead
to problems.  Better to have int4, int4, int4, int
----------------------------------------------------------------------
- timing on mac: 32k particles, 360k grid: 25ms for density (used to be 50 ms)
----------------------------------------------------------------------
	kern.setArg(iarg++, cl_sort_hashes->getDevicePtr());  // size: nb_el
	kern.setArg(iarg++, cl_cell_indices_nb->getDevicePtr()); // grid size
	kern.setArg(iarg++, cl_cell_indices_start->getDevicePtr()); // grid size
----------------------------------------------------------------------
One reason density computation is so slow (70 ms) with new compact arrays is that density 
is a float4 (and not a float) to simplify my programming. So global memory access is more expensive
----------------------------------------------------------------------
